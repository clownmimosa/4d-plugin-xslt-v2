/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-XSLT.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : XSLT
 #	author : miyako
 #	2019/09/17
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-XSLT.h"

#pragma mark -

void OnStartup()
{
    xmlInitParser();
    exsltRegisterAll();
    
    /*
     xmlMemSetup must be the very first call to libxml2 then call
         xmlInitParser(). Don't call xmlInitMemory by yourself, xmlInitParser
         will do it.
         https://mail.gnome.org/archives/xml/2007-August/msg00037.html
     */
}

void OnExit()
{
    xsltCleanupGlobals();
    xmlCleanupParser();
    
    /*
     WARNING: if your application is multithreaded or has plugin support calling this may crash the application if another thread or a plugin is still using libxml2. It's sometimes very hard to guess if libxml2 is in use in the application, some libraries or plugins may use it without notice. In case of doubt abstain from calling this function or do it just before calling exit() to avoid leak reports from valgrind !
         http://xmlsoft.org/html/libxml-parser.html#xmlCleanupParser
     */
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnStartup, NULL);
                break;
                
            case kDeinitPlugin :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnExit, NULL);
                break;
                
			// --- XSLT
            
			case 1 :
				XSLT_Apply_stylesheet(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

BOOL is_file_path(PA_Handle h) {
    
    BOOL result = FALSE;
    
    if(h) {
        
        PA_long32 size = PA_GetHandleSize(h);
        
        if(size < 1024) {
            
            C_TEXT t;
            t.setUTF8String((const uint8_t *)PA_LockHandle(h), size);
            PA_UnlockHandle(h);
            
            PA_Variable    params[1];
            params[0] = PA_CreateVariable(eVK_Unistring);
            PA_Unistring path = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
            PA_SetStringVariable(&params[0], &path);
            result = (1 == PA_GetLongintVariable(PA_ExecuteCommandByID(476 /* test path name */, params, 1)));
            PA_ClearVariable(&params[0]);
    
        }
        
    }

    return result;
}

xmlDocPtr parse_xml_doc(PA_Handle h, int options) {
    
    xmlDocPtr xmlDoc = 0;
    
    if(h) {
        
        if(is_file_path(h))
        {
            /* convert path hfs to posix */
#if VERSIONMAC
            NSString *str = [[NSString alloc]initWithUTF8String:(const char *)PA_LockHandle(h)];
            PA_UnlockHandle(h);
            if(str) {
                
                NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault,
                                                                    (CFStringRef)str, kCFURLHFSPathStyle, false);
                if(url) {
                    NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
                    if(path) {
                        xmlDoc = xmlParseFile((const char *)[path UTF8String]);
                        [path release];
                    }
                    [url release];
                }
                [str release];
            }
#else
            xmlDoc = xmlParseFile((const char *)PA_LockHandle(h));
            PA_UnlockHandle(h);
#endif

        }else
        {
            xmlDoc = xmlParseMemory(PA_LockHandle(h), PA_GetHandleSize(h));
            PA_UnlockHandle(h);
        }
        
        if(xmlDoc) {
            xmlXIncludeProcessFlags(xmlDoc, options);
        }
        
    }
    
    return xmlDoc;
}

xsltStylesheetPtr parse_xsl_doc(PA_Handle h, int options) {
    
    xsltStylesheetPtr xslDoc = 0;
    
    xmlDocPtr xmlDoc = parse_xml_doc(h, options);
    
    if(xmlDoc) {
        /* xsltFreeStylesheet(xslDoc) will free xmlDoc */
        xslDoc = xsltParseStylesheetDoc(xmlDoc);
    }
    
    return xslDoc;
}

#pragma mark -

void XSLT_Apply_stylesheet(PA_PluginParameters params) {

    C_BLOB returnValue;
    
    PA_Handle xml = PA_GetBlobHandleParameter(params, 1);
    PA_Handle xsl = PA_GetBlobHandleParameter(params, 2);
    
    std::vector<const char *> xslParams;
    std::vector<std::string> xslParamsValues;
    
    CUTF8String json_options;
    PA_ObjectRef options = PA_GetObjectParameter(params, 3);
    if(options) {
        ob_stringify(options, &json_options);
        Json::Value root;
        Json::CharReaderBuilder builder;
        std::string errors;
        
        Json::CharReader *reader = builder.newCharReader();
        bool parse = reader->parse((const char *)json_options.c_str(),
                                   (const char *)json_options.c_str() + json_options.size(),
                                   &root,
                                   &errors);
        if(parse)
        {
            if(root.isObject())
            {
                for(Json::Value::const_iterator it = root.begin() ; it != root.end() ; it++)
                {
                    Json::Value key = it.key();
                    JSONCPP_STRING name = it.name();
                    
                    
                    if(it->isString())
                    {
                        xslParamsValues.push_back(std::string(key.asString())); 
                        xslParamsValues.push_back(std::string(it->asString()));
                    }
                }
            }
        }
    }
    
    for(size_t i = 0; i < xslParamsValues.size(); ++i) {
       xslParams.push_back(xslParamsValues.at(i).c_str());
    }
    
    xslParams.push_back(NULL);

    int xmlParserOption = XSLT_PARSE_OPTIONS;
    int xslParserOption = XSLT_PARSE_OPTIONS;
    
    if(ob_is_defined(options, L"xmlParserOption"))
    {
        xmlParserOption |= (int)ob_get_n(options, L"xmlParserOption");
    }
    
    if(ob_is_defined(options, L"xslParserOption"))
    {
        xslParserOption |= (int)ob_get_n(options, L"xslParserOption");
    }

    xmlDocPtr xmlDoc = parse_xml_doc(xml, xmlParserOption);
    if (xmlDoc) {
        xsltStylesheetPtr xslDoc = parse_xsl_doc(xsl, xslParserOption);
        if(xslDoc) {
            
            xsltTransformContextPtr ctxt = xsltNewTransformContext(xslDoc, xmlDoc);
            
            xmlDocPtr outDoc = xsltApplyStylesheetUser (xslDoc,
                                                        xmlDoc, &xslParams[0],
                                                        NULL, NULL, ctxt);
            
            if(outDoc)
            {
                xmlOutputBufferPtr outputBuffer = xmlAllocOutputBuffer(0);
                if(outputBuffer) {
                    // mysteriously, 0 is returned
                    // http://xmlsoft.org/XSLT/html/libxslt-xsltutils.html#xsltSaveResultTo
                    xsltSaveResultTo (outputBuffer, outDoc, xslDoc);
                    size_t resultLength = xmlOutputBufferGetSize(outputBuffer);
                    if (resultLength)
                    {
                        PA_ReturnBlob(params, (void *)xmlOutputBufferGetContent(outputBuffer), (PA_long32)resultLength);
                    }
                    xmlOutputBufferClose(outputBuffer);
                }
                xmlFreeDoc(outDoc);
            }
            xsltFreeStylesheet(xslDoc);
        }
        if(xmlDoc) xmlFreeDoc(xmlDoc);
    }
    
}

